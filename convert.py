#!/usr/bin/env python3

"""
Script to convert specially crafted C-like code to brainfuck.
It only works with the "simplified" output of interpret.c

It only accepts a very limited amount of expressions, no functions / functions calls, pointers,
 and only the varibles data, which is an array and p which is a index that points to this array.
It only works with the data structure used in interpret.c, where data is split into blocks of 8
 elements, where the last element of each block can be used to copy variables.
It only accepts while( data[ p +/- ....] ) without comparision, and no if, else, for, switch, goto,
 do{}while(), ...

The input file must pe preprocessed before to remove any commends and preprocessor statements.
Remove any lines startign with # (generated by gcc)

The generated brainfuck code should have the same line count as the input file and the brainfuck
 code should end up in about the same line as the C-like code was from which that statement was
 copied from.

"""

import sys
import re

class SyntaxError(Exception):
  "Throw this when we can't parse a input"
  def __init__(self,text,statements=""):
    self.text=text
    self.line=None
    self.statements=statements
  def setLine(self,line):
    self.line=line
  def __str__(self):
    return "Error on line "+str(self.line)+": "+self.text+" Statements: "+str(self.statements)

class Output(object):
  """
  Class to output the brainfuck code.
  It does a minimal amount of optimatzion (for example eliminating <>, ><, -+ and +-, which are
   noop's that hurt performance
  """
  def __init__(self,out=sys.stdout):
    self.out=out
    self.currentOffset=0
    self.currentAdd=0
    self.whileOffsets=[]
    self.shouldPrintNewline=0 #number of new lines we should print at the next oppertinuity.
  def _printAdd(self):
    "Print the + and - for the current position. Print nothing when we don't need to"
    print( ('+' if self.currentAdd>0 else '-')*abs(self.currentAdd), end='', file=self.out )
    if self.currentAdd :
      print("\n"*self.shouldPrintNewline, end='', file=self.out)
      self.shouldPrintNewline=0
    self.currentAdd=0
  def _printOffset(self):
    "Print the > and < for the current position. Print nothing when we don't need to"
    print( ('>' if self.currentOffset>0 else '<')*abs(self.currentOffset), end='', file=self.out )
    if self.currentOffset :
      print("\n"*self.shouldPrintNewline, end='', file=self.out)
      self.shouldPrintNewline=0
    self.currentOffset=0
  def goto(self,offset):
    "Move the pointer p / move the tape (< and >) by the ammount offset"
    if offset:
      self._printAdd()
    self.currentOffset = self.currentOffset + offset
  def add(self,n):
    "increase or decrease the value of the current cell by n"
    if n:
      self._printOffset()
    self.currentAdd = self.currentAdd + n
  def flush(self):
    "complete the currently pending operations"
    self._printOffset()
    self._printAdd()
  def command(self,command):
    self.flush()
    print(command, end='', file=self.out)
  def nextLine(self):
    "Used to make sure we have the same amount of lines as in the source"
    #Don't print the newlines yet, maybe we can optimitze something before going to the next line
    # but for that we have to wait till we know what code we should print next
    self.shouldPrintNewline = self.shouldPrintNewline+1

  def commandOffset(self,command,offset):
    "Execute a command at a cell that is <offset> away from the current cell"
    self.goto(offset)
    self.command(command)
    self.goto(-offset)
  def startWhile(self,offset):
    "Start with a new loop"
    self.commandOffset('[',offset)
    self.whileOffsets.append(offset)
  def endWhile(self):
    "end the loop"
    offset=self.whileOffsets.pop()
    self.commandOffset(']',offset)
  def setValue(self,offset,value):
    "Clear a cell and set it to a value after that."
    command = '[-]'+('+' if value>0 else '-')*abs(value)
    self.commandOffset(command,offset)
  def copyValue(self,sourceOffset,targetOffset,temporaryOffset):
    """
    Copy a value from one cell with offset sourceOffset to a different cell with offset
     targetOffset. Use the cell with offset temporaryOffset not lose the value in the source cell
    """

    #clear the target cell
    self.commandOffset('[-]',targetOffset)

    #Copy the value from source to target and the temporary cell. source cell will lose the value
    self.commandOffset('[-',sourceOffset)
    self.commandOffset('+',temporaryOffset)
    self.commandOffset('+',targetOffset)
    self.commandOffset(']',sourceOffset)

    #Move the value from the temporary cell back to the source cell, so the source has the original
    # value
    self.commandOffset('[-',temporaryOffset)
    self.commandOffset('+',sourceOffset)
    self.commandOffset(']',temporaryOffset)

  def addOffset(self,offset,value):
    "Add a fixed value to a cell at a specific offset"
    self.goto(offset)
    self.add(value)
    self.goto(-offset)


def getAccessOffset(statements):
  """
  Parse the data inside data[ ... ] 
  It should contain a statement like p, p+12, p-3, p+6-2, ...
  This returns the offset of the data inside the [ ... ] (relative to p) and the statments after
   the ] for further processing
  """
  if len(statements)<4:
    raise SyntaxError("Expected data[<something>] but there are too few statements",statements)
  if statements[0]!='data':
    raise SyntaxError("expected data [<something] got ",statements[0],statements)
  if statements[1]!='[':
    raise SyntaxError("expected [ got ",statements[1],statements)

  statements=statements[2:]

  if len(statements)<2:
    raise SyntaxError("data[...] access without enoug elements",statements)
  if statements[0]!='p':
    raise SyntaxError("data[...] access that doesn't start with a p",statements)
  statements=statements[1:]

  #After the p, we accept an arbitary amount of +<N> and -<M> statments (where N and M are fixed
  # values
  n=0 #offset from p
  while 1:
    if len(statements)<1 or statements[0]==']':
      return n,statements[1:]
    if statements[0]=='+':
      n=n+int(statements[1])
      statements=statements[2:]
    elif statements[0]=='-':
      n=n-int(statements[1])
      statements=statements[2:]
    else:
      raise SyntaxError("data[...] with unknown statement"+str(statements[0]),statements)



output=Output()
#Which offset we use to store a temporary variable. We need such a cell to copy a value
temporaryCellOffset=1


def handleWriteChar(statements):
  " Call this to handle a statement to write a character/byte "
  if len(statements)<4 or statements[1]!='(' or statements[-1]!=')':
    raise SyntaxError("Unexpected data for write_char",statements)

  offset,statements = getAccessOffset(statements[2:-1])
  if len(statements):
    raise SyntaxError("Found additional data after write_char ( data[...] ) ",statements)
  output.commandOffset('.',offset)

def handleWhile(statements):
  " Call this when we found a statement that ends in a { (only used / accepted for while loops)"
  if len(statements)<4:
    raise SyntaxError("Found { without a proper while statement",statements)
  if statements[0]!='while':
    raise SyntaxError("Found { without while",statements)
  if statements[1]!='(':
    raise SyntaxError("Found while without (",statements)
  if statements[-1]!=')':
    raise SyntaxError("Found while without )",statements)

  offset,statements = getAccessOffset(statements[2:-1])
  if len(statements):
    raise SyntaxError("Found additional data after while (...) ",statements)
  output.startWhile(offset)

def endWhile(statements):
  " Call this when we found a } (only used / accepted at the end of a while loop)"
  if len(statements)>1:
    raise SyntaxError("Found } with extra, unexpected data",statements)
  output.endWhile()


def handleExpression(statements):
  " Call this when we found a ; "
  if len(statements)<2:
    raise SyntaxError("not enough elements for assignment",statements)

  setP=0 #set to 1 when this statements moved the pointer / index p
  targetOffset=None #used when we set a cell, gives the offset to the pointer / index p
  if statements[0]=='data':
    targetOffset,statements = getAccessOffset(statements)
  elif statements[0]=='p':
    setP=1
    statements = statements[1:]
    if len(statements)==2:
      if statements[0]=='+' and statements[1]=='+':
        output.add(1)
        return
      if statements[0]=='-' and statements[1]=='-':
        output.add(-1)
        return
  elif statements[0]=='write_char':
    handleWriteChar(statements)
    return
  else:
    raise SyntaxError("Unknwon how to handle "+statements[0],statements)

  #add is either the value we add to a cell or pointer / index. Or a absolute value which we use to 
  # set a cell
  add=0
  startOffset=None #set this when we copy a value from one cell (to a other or the same cell)
  if len(statements)<2:
    raise SyntaxError("not enough elements for assignment",statements)
  if statements[0]!='=':
    if len(statements)==2 and statements[0]=='-' and statements[1]=='-':
      startOffset=targetOffset
      add=-1
    elif len(statements)==2 and statements[0]=='+' and statements[1]=='+':
      startOffset=targetOffset
      add=+1
    else:
      raise SyntaxError("expected =, ++ or -- got "+statements[0],statements)
    statements=[]
  else:
    statements=statements[1:]


    if statements[0]=='data':
      if setP:
        raise SyntaxError("can not set p from data",statements)
      startOffset,statements = getAccessOffset(statements)

    elif statements[0]=='p':
      if not setP:
        raise SyntaxError("can not set data from p",statements)
      statements=statements[1:]


  #We accept any +/-<N> after it, where N maybe an absolute value or a character constant
  #Alternatively, a read_char() command is used to read one byte from the input
  isReadChar=0
  while len(statements):
    if statements[0] in '0123456789':
      if add or isReadChar:
        raise SyntaxError("Unexpected integer",statements)
      add = int(statements[0])
      statements=statements[1:]

    elif statements[0]=='+' or statements[0]=='-':
      isAddition = statements[0]=='+'
      n=0
      if len(statements)<2:
        raise SyntaxError("Expected something after +",statements)
      if statements[1]=="'":
        if len(statements)<3:
          raise SyntaxError("Not enough elements for character literal",statements)
        if statements[3]!="'":
          raise SyntaxError("No valid character literal",statements)
        n = ord(statements[2])
        statements=statements[4:]
      else:
        n = int(statements[1])
        statements=statements[2:]
      if isAddition:
        add = add + n
      else:
        add = add - n

    elif statements[0]=='read_char':
      if len(statements)<3:
        raise SyntaxError("Expected () after read_char",statements)
      if statements[1]!="(" or statements[2]!=')' :
        raise SyntaxError("Expected () after read_char",statements)
      isReadChar=1
      statements=statements[3:]
    else:
      raise SyntaxError("expected + or - got "+statements[0],statements)


  if setP: #We move the pointer/index
    if targetOffset is not None or startOffset is not None or isReadChar:
      raise SyntaxError("can not set p from data"+statements[0],statements)
    output.goto(add)
    return

  if targetOffset is None: #We need a location to store the result
    raise SyntaxError("Unexpected assignment format",statements)

  if isReadChar: #read a character and store it in the cell with offset targetOffset
    if startOffset is not None or add:
      raise SyntaxError("can not add read_char() with data ",statements)
    output.commandOffset(',',targetOffset)
    return

  #When we don't have a source cell, we need to set target cell to an absolute value
  if startOffset is None:
    output.setValue(targetOffset,add)
    return

  #If source and target are the same cell, we need to increment/decrement this cell by a specific
  # amount
  if startOffset == targetOffset:
    output.addOffset(targetOffset,add)
    return

  #Copy a cell to target cell and to cell with offset temporaryCellOffset
  #After that we copy cell with temporaryCellOffset to source cell
  #And after that we may need to add/substract a fixed value
  output.copyValue(startOffset,targetOffset,temporaryCellOffset)
  if add:
    output.addOffset(targetOffset,add)




def addElementStatement(statement,element):
  " Call this for every token found in the source file "
  element=element.strip()
  if len(element)==0:
    return statement
  #If the current token is either {, } or ;, we process the current statement.
  if '{' in e:
    handleWhile(statement)
    statement=[]
  elif '}' in e:
    endWhile(statement)
    statement=[]
  elif ';' in e:
    handleExpression(statement)
    statement=[]
  else:
    statement.append(element)
  return statement



statement=[]
for line,i in enumerate(sys.stdin):
  try:
    #Split the code into tokens
    for e in re.split('([^a-zA-Z0-9_])',i):
      line=0
      if '\n' in e:
        line =1
      statement = addElementStatement(statement,e)
      if line: output.nextLine()
  except SyntaxError as e:
    e.setLine(line+1)
    raise

try:
  if len(addElementStatement(statement,e)):
    raise SyntaxError("Extra data at the end of the file")
except SyntaxError as e:
  e.setLine(line)
  raise

output.flush()


